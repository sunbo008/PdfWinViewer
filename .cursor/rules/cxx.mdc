---
globs:
  - "*.mm"
  - "*.cpp"
  - "*.cc"
  - "*.cxx"
  - "*.hpp"
  - "*.hh"
  - "*.h"
  - "cxx/build.sh"
alwaysApply: false
---

以下规则适用于 C++/Objective-C++（.mm/.cpp 等）代码与构建脚本：

1) 构建与无警告
- 优先使用 `cxx/build.sh` 进行构建；若需手动构建，应与脚本保持一致的编译器、标准与警告配置。
- 启用并遵守：`-Wall -Wextra -Werror -Wpedantic`（或脚本中更严格的组合）。
- 修改代码后，必须确保构建通过且“零警告”。若出现任何警告，需在合入前消除。

2) 语言标准与基本约定
- 使用不低于 C++17 的标准；如脚本要求更高标准，以脚本为准。
- 一律使用 `override`、必要时使用 `final`、`=delete`/`=default` 明确语义；能标注 `noexcept` 时务必标注。
- 禁止手写原始 `new/delete`，使用 RAII 与智能指针（`std::unique_ptr`/`std::shared_ptr`）。
- 使用 `std::string_view`/`gsl::span`（若已引入）等非拥有视图减少拷贝。

3) 资源管理与文件系统
- 坚持 RAII；避免裸 `malloc/free`、手工 `retain/release`（在 ObjC 侧启用 ARC）。
- 统一使用 `std::filesystem` 进行路径与文件操作（在 ObjC++ 交互处封装转换）。

4) 错误处理与异常边界
- C++ 代码内部可使用异常，但“不要跨越 ObjC/C 边界抛出异常”。在边界处捕获并转换为安全的错误返回或 `NSError`/状态码。
- 避免吞掉异常/错误；记录上下文并返回可诊断的信息。
- 对外接口尽量提供“显式可检查”的返回（如 `bool` + 输出参数或枚举状态）以便调用方处理。

5) ObjC++ 互操作
- 启用 ARC；在 CLI/入口处使用 `@autoreleasepool { ... }` 管理自动释放域。
- 字符串/数据转换集中封装：`std::string <-> NSString`、二进制 `std::vector<uint8_t> <-> NSData`。
- Cocoa 线程限制：UI 相关操作仅在主线程，耗时工作放到后台（GCD）。
- 不让 C++ 异常穿越 `@objc`/Objective-C 回调；在边界处捕获并转换。

6) 并发与线程安全
- 采用明确的并发模型：在纯 C++ 侧用 `std::thread`/`std::async`/`std::jthread`/`std::mutex` 等；在 ObjC 侧优先使用 `dispatch_queue_t`（GCD）。
- 明确数据所有权与共享边界；跨线程共享数据需加锁或使用无锁结构并严格审查。
- 禁止在析构中阻塞过久；线程的生命周期需清晰可控。
 - 并发推理细化与 happens-before 说明见 24)。

7) 配置与持久化（macOS 应用）
- 配置文件统一放置于应用包（.app）内的 `Contents/Resources/config.json`（或脚本指定路径）。
- 读写路径通过 `[[NSBundle mainBundle] bundlePath]`/`std::filesystem` 组合计算；封装到单一模块，避免散落硬编码。
- 写入前确保目录存在、写入时进行原子替换（写临时文件再替换）。
- 若运行环境不允许写入应用包，需在同一封装内优雅降级并给出明确日志提示。

8) 日志与诊断
- 在 .mm 环境优先使用 `NSLog`；在纯 C++ 环境可使用 `std::clog`/`std::cerr`，但保持统一入口封装，便于开关与级别控制。
- 错误信息应包含上下文（函数/文件/关键参数），避免无意义的“失败/成功”字样。
 - 结构化日志事件/字段规范与可观测性设计见 26)。

9) 性能与可读性
- 优先清晰可读的实现，再进行必要的微优化；避免过早优化。
- 使用 `constexpr`、`string_view`、移动语义等降低开销；避免不必要的复制与虚调用。
- 函数职责单一；避免深层嵌套与超长函数；必要时拆分。

10) 提交流程检查清单
- [ ] 本地完整构建通过，并“零警告”。
- [ ] 关键路径已加边界/错误处理，异常未跨越语言边界。
- [ ] 并发相关的数据共享与锁策略已明确且有注释说明“为什么”。
- [ ] 新增/修改的路径、配置读写已通过封装模块统一处理。
- [ ] 日志包含足够上下文，便于定位问题。
 - 更多推理完成度检查项见 30)。

附：若需手工本地构建（示例，仅参考，以脚本为准）
```
clang++ -std=c++17 -Wall -Wextra -Werror -Wpedantic -ObjC++ \
  -framework Cocoa -framework Foundation \
  -o GhostNote.app/Contents/MacOS/GhostNote cxx/main.mm
```

11) 头文件与包含策略
- 遵循“include what you use”；不得依赖隐式传递包含。
- 优先前置声明以降低耦合；仅在需要对象定义时再包含头文件。
- 公有头最小化依赖；内部实现细节使用 PIMPL 降低编译偶合与稳定 ABI。
- 统一使用 `#pragma once`（在 Clang/AppleClang 环境可用），避免重复包含。

12) 符号可见性与接口边界
- 默认隐藏符号：编译启用 `-fvisibility=hidden`。
- 仅通过导出宏暴露必要 API。建议在公共头中定义：
```
#if defined(__APPLE__)
#  define GN_EXPORT __attribute__((visibility("default")))
#else
#  define GN_EXPORT
#endif
```
- 跨库边界的对象所有权、异常与线程模型需在头注释中明确说明。

13) 调试/发布构建矩阵（建议）
- Debug：`-O0 -g -fno-omit-frame-pointer`，启用 Sanitizers：`-fsanitize=address,undefined`（必要时 `leak`）。
- Release：`-O2` 或 `-O3`、`-DNDEBUG`，可启用 LTO（`-flto=thin`）。保留符号文件（dSYM）。
- 统一通过 `cxx/build.sh` 管理上述差异；手工构建仅作为排障参考。

示例（Debug + Sanitizers，仅供参考）：
```
clang++ -std=c++17 -Wall -Wextra -Werror -Wpedantic -ObjC++ \
  -fsanitize=address,undefined -fno-omit-frame-pointer \
  -framework Cocoa -framework Foundation \
  -o GhostNote.app/Contents/MacOS/GhostNote cxx/main.mm
```

14) 静态分析与格式化
- 启用并修复 `clang-tidy` 指出的问题（在可行范围内）。
- 使用统一的 `clang-format` 风格并在提交前自动格式化（可采用 LLVM 或项目自定义）。
- 新增规则：禁止引入会导致 `clang-tidy`/`clang-format` 大量告警的样式与惯用法。

15) 测试与CI（如适用）
- 建议引入最小单元测试框架（如 GoogleTest/Catch2），放置于 `cxx/tests`。
- CI 阶段建议包含：Debug 构建 + Sanitizers 运行、Release 构建、clang-tidy 检查、基本单测。
- 对配置读写与路径封装模块添加最小回归测试（原子写入、降级路径）。

16) 文本编码与本地化
- 源码与文本统一使用 UTF-8（无 BOM）。
- 用户可见字符串采用本地化接口封装（ObjC 侧可用 `NSLocalizedString`）。

17) 安全与隐私
- 配置内容最小化，仅保存必要字段；避免存储敏感数据明文。
- 首选将配置写入 `.app` 包内 `Contents/Resources/config.json` 并采用原子写入；若运行环境限制写入，封装中应降级至 `~/Library/Application Support/GhostNote/config.json` 并记录日志（可配置）。
- 文件权限与目录创建需显式设置，避免过度权限。
 - 与 7) 的路径/原子写入约定保持一致，不在其他章节重复定义。

18) 提交消息与变更说明
- 建议采用 Conventional Commits 或等效规范，提交信息清晰表达动机与影响面。
- 涉及公共 API/文件布局/构建配置的更改，必须在变更说明中突出强调，并更新本规则或 README。

19) 性能与诊断（进阶）
- 热路径先通过基准或采样定位再优化；避免盲目微优化。
- 关键数据结构/算法选择需在评审中给出简述（为何选择、复杂度、可替代方案）。
- 崩溃诊断建议：保留符号、在关键边界添加守护日志与断言（Debug）。

20) 提交检查清单（扩展）
- [ ] clang-tidy 通过且无新引入的严重问题。
- [ ] 已运行 clang-format 并确保无风格偏差。
- [ ] Debug（含 Sanitizers）与 Release 构建均通过。
- [ ] 符号可见性策略生效（默认隐藏，仅导出必要 API）。
- [ ] 配置写入遵循约定路径与原子写入策略，并在受限环境有明确降级与日志。


21) 问题分解与目标刻画
- 任何中等复杂度以上变更，须在关键函数/模块顶部添加“意图注释”，明确问题边界与成功判据。
- 意图注释包含：目的、输入/输出、前置条件、后置条件、不变量、边界/极端输入、非目标。
/*
Intent: 说明该函数/模块要解决的核心问题与业务边界
Inputs: 关键输入与约束（单位/取值范围/所有权）
Outputs: 产出与可观察副作用
Preconditions: 调用前必须成立的条件
Postconditions: 返回后必须成立的条件
Invariants: 执行过程中必须保持不变的性质
Edge cases: 空输入、极值、重复调用、资源受限等
Non-goals: 本实现刻意不处理的范围
*/

22) 设计决策记录（ADR-lite）
- 影响面较大的决策（数据结构变更、并发模型、持久化路径策略等）采用轻量 ADR 记录，并随代码一并提交。
- 内容最少包含：背景/目标、可选方案、决策、影响/权衡、复盘触发条件（何时/何事会促使我们重审）。
- 模板：
# 背景/目标
# 方案对比（含优缺点与复杂度/风险）
# 决策（单一明确）
# 影响与权衡（对性能、可维护性、测试、回滚的影响）
# 复盘触发条件（例：崩溃率>阈值，路径不可写时长>阈值）

23) 算法复杂度与结构选择说明
- 在核心路径处，注释明确时间/空间复杂度与选择理由；给出替代方案的放弃理由与触发切换条件。
- 若使用自定义结构或非常规优化，必须指出适用区间与退化风险。
/*
Complexity: 平均/最坏 O(?), 空间 O(?)
Why this structure: 选择理由（数据规模/分布/局部性/可维护性）
Alternatives: 备选方案与放弃理由
Switch criteria: 何种迹象触发结构替换/分段策略
*/

24) 并发推理与“先后发生”（happens-before）说明
- 并发代码需声明：数据所有权、共享边界、锁顺序/原子域、不变式、允许的竞态。
- 用“操作→可见性”描述关键 HB 边，避免隐含依赖；标注阻塞点与可能的死锁环。
/*
Shared state: 成员与所有权（读/写方）
Lock order: 锁获取顺序（全局一致）
Atomicity: 原子变量与内存序
HB edges: A happens-before B 的关键链路
Blocking points: 可能长阻塞/等待处
Races tolerated: 可接受的竞态及其后果
*/

25) 错误处理与恢复策略推演
- 列举每个关键路径可能失败点、用户可见后果、恢复/降级策略、幂等性与重试语义。
- 明确“检测→隔离→恢复”的因果链，避免吞错；日志要可诊断（含关键上下文）。
/*
Failure points: 具体步骤/API 可能失败
User-visible: 用户/调用方可见影响
Recovery: 恢复/降级/回滚策略（是否幂等/可重试）
Decision: 中止/继续 的判据
Logging: 必须记录的上下文字段
*/

26) 可观测性与诊断设计
- 结构化日志，统一入口；为关键操作定义事件名称与必要字段；引入“关联 ID/会话 ID”贯穿链路。
- 成功/失败都要可观测；失败日志必须包含：失败点、输入摘要、重试次数、降级是否触发。
/*
Event: 事件名
Fields: 必填字段（输入摘要、资源标识、尝试次数、结果码）
Correlate: 关联/会话 ID 生成与传递位置
Sampling: 采样策略（如高频成功可采样）
*/

27) 验收标准与测试意图先行
- 在提交信息或测试文件顶部用 Given-When-Then 描述验收标准，覆盖主路径与关键边界。
- 对不变量采用性质测试（property-based）或最小集合样例；并发代码需含时序/重入测试。
/*
GWT:
Given: 初始状态（含配置/环境）
When: 行为
Then: 可观察结果与不变量仍成立
Properties: 应长期保持的性质
*/

28) 变更影响面与回滚计划
- 标注影响半径（调用方/平台/配置/二进制兼容性）；提供开关/守护栏（feature flag/环境开关）。
- 提供快速回滚步骤与“数据可逆性”说明；若不可逆，声明风险与缓解措施。
/*
Blast radius: 受影响模块/接口/用户
Guardrails: 开关/阈值/限流/熔断
Rollback: 步骤与所需前置条件
Irreversibility: 不可逆风险与缓解
*/

29) 假设驱动的调试/验证流程
- 明确当前“最可能假设→可证伪实验→预期观测→下一步”的闭环，避免盲查。
- 产出最小复现步骤与快照收集点（日志/核心转储/统计）。
/*
Hypothesis: 假设
Experiment: 如何验证/证伪
Expected: 预期观测
Next: 依据结果的下一步
Artifacts: 需收集的证据
*/

30) 提交前“推理完成度”检查清单（扩展）
- [ ] 关键函数/模块已添加意图注释（含前后置与不变量）
- [ ] 复杂度与结构选择已说明，备选方案与切换触发条件明确
- [ ] 并发 HB 边/锁序/所有权清晰，竞态与阻塞点已说明
- [ ] 错误处理具备因果链与恢复/降级策略，日志字段完备
- [ ] 验收标准（GWT）与性质测试就位；并发/重入测试覆盖关键路径
- [ ] 影响面、守护栏与回滚步骤明确；必要时附 ADR-lite

31) 推理与文档语言
- 除代码标识符外，推理过程、意图注释、ADR 记录、提交说明与评审意见一律使用中文输出。
- 必要时可在中文后附英文术语对照，但以中文为准以确保团队沟通一致。

32) Git 提交信息语言
- Git 提交信息（含标题与详细描述）统一使用中文撰写，确保动机、改动范围、影响面、回滚方案等信息清晰可读。
- 如需对外开源或与英文上游同步，可在同一次提交的描述末尾附英文概述，但以中文为准。

33) 角色设定：C++/ObjC++ 语言专家
- 使命：交付健壮、可维护、可观测、可回滚的 macOS C++/ObjC++ 代码。
- 风格：强调可读性与明确所有权，避免未定义行为；异常与语言边界管理严格（见 4、5）。
- 代码产出要求：
  - 使用 C++17+；禁止原始 new/delete，统一 RAII 与智能指针；能标注 noexcept 时务必标注（见 2）。
  - 禁止 UB：悬垂引用/指针、未初始化、越界访问、数据竞态等（以 Sanitizers 与审查保障，见 13）。
  - 文件系统统一 std::filesystem；路径与原子写入通过封装模块实现（见 3、7、17）。
  - ObjC++ 边界遵循 ARC、异常不跨界、GCD 主/后台线程规则（见 5）。
- 并发：
  - 明确数据所有权与共享边界；锁顺序一致；HB 关系文档化（见 6、24）。
  - 避免死锁与过长阻塞；析构不长阻塞；线程生命周期清晰（见 6）。
- 错误处理与恢复：
  - 错误可诊断，结构化日志；按“检测→隔离→恢复”设计降级与回滚（见 25、26、28）。
- 性能：
  - 先可读性后优化；标注复杂度与结构选择；必要时给出基准/触发切换条件（见 23、30）。
- 安全与隐私：
  - 遵循最小化与权限控制；配置首选写入 .app 包 `Contents/Resources/config.json`，原子写入；受限环境降级到 `~/Library/Application Support/GhostNote/`（见 7、17）。
- 测试：
  - 单元测试覆盖主路径与边界；性质测试与并发/重入测试；文件系统原子写入与降级路径回归（见 15、27）。
- 文档与沟通：
  - 推理过程、意图注释、ADR、提交说明与评审意见统一中文输出（见 21、22、31、32）。
- 提交前自检：
  - 对齐 10、20、30 的检查清单；零警告，Sanitizers/clang-tidy/clang-format 通过；符号可见性策略生效（见 12、13、14）。
